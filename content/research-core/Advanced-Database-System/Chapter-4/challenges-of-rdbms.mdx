---
title: Challenges of RDBMS
description:
parent: NOSQL
grand_parent : Advanced Database System
order: 1
completed: true
---

### Early Search Engines:

* **Archie (1990):**
    * Developed at McGill University by three students.
    * It indexed FTP sites by filename, making it the first to index internet files.
    * However, it didn't meet the full criteria of a "search engine" by modern standards since it lacked full-text search capabilities.

* **Veronica (1993):**
    * Created at the University of Nevada as part of the Gopher information retrieval system.
    * It could be considered the first real search engine, as it provided more advanced search capabilities than Archie.

* **Inktomi:**
    * A more advanced search engine, it later served as the search backend for Yahoo!.
    * It set the foundation for what would evolve into modern search engines.

### Challenges of RDBMS:
RDBMSs have been the backbone of structured data management for decades. However, they encounter significant challenges when dealing with large-scale, sparse data. Some key assumptions in RDBMS models include:

* Data attributes are well-defined and structured.
* Relationships exist between data entities.
* Indexing is used to optimize query performance.
* Some flexibility is allowed for missing or irregular data.

However, as data volumes grow and the variety of data increases (especially with the rise of unstructured data), RDBMSs begin to show limitations. Specifically, they struggle with:
* **Handling large-scale sparse data:** Data with missing attributes or unstructured formats doesn’t fit well within the rigid schema of an RDBMS.
* **Scaling:** RDBMSs are less efficient when managing vast amounts of distributed data.

### Handling Large-Scale Sparse Data
Sparse data refers to datasets where a significant number of values are missing, or where data is irregular and not densely populated. For example, a survey dataset with many unanswered questions would be considered sparse. Here’s why sparse data is challenging:

#### Challenges with Sparse Data:
* **Wasted Space:** Sparse data often means a lot of empty or null values in a database table or data structure. In RDBMS, this leads to inefficient storage because even empty fields take up space.
* **Complexity in Queries:** Queries involving sparse data can become inefficient. For example, if a dataset has many NULL values or missing attributes, it can complicate filtering, indexing, and querying.
* **Difficulty in Structuring:** RDBMSs are designed to work with structured data, where *every attribute is expected to be present* for each record. Sparse data doesn't fit well into this structure because not every record has values for every attribute.

#### How RDBMS Handle Sparse Data:
In traditional RDBMS systems, sparse data is typically handled by:
* **NULL values:** RDBMS allows columns to store NULL values when data is missing. While this helps store sparse data, it makes operations (like joins or aggregations) slower and more complicated.
* **Sparse Arrays or Compressed Formats:** In some systems, to optimize space, sparse arrays or compressed formats may be used to store only non-null or non-empty values. However, this isn’t always a perfect solution for relational data, especially with complex relationships.

#### Alternatives:
**NoSQL Databases:** NoSQL databases like MongoDB or Cassandra are better suited for sparse data. They allow for flexible schema designs where each **record (or document) can have different attributes,** reducing the overhead caused by missing data.

### Scaling
Scaling refers to the ability of a system to handle increased load, either in terms of data volume (more data) or user traffic (more queries, transactions, or requests). Scaling challenges arise when data grows too large for a single machine or system to handle efficiently.
#### Types of Scaling:
* **Vertical Scaling (Scaling Up):** This involves adding more resources (e.g., CPU, RAM, disk space) to a single machine to handle more data or traffic. While it’s simple, there are physical limitations to how much a single machine can handle, and it can become costly and inefficient for extremely large datasets.

* **Horizontal Scaling (Scaling Out):** This involves adding more machines to a system, distributing the workload across multiple nodes. This is the more common method for scaling modern data systems because it allows for handling significantly larger datasets and higher loads. Horizontal scaling is a key feature of modern distributed systems, such as NoSQL databases and Hadoop.

#### Scaling Challenges:
* **Data Partitioning:** In horizontally scaled systems, data must be split into smaller parts (called shards or partitions) to be distributed across different machines. This requires strategies for dividing data in a way that maintains integrity, consistency, and efficient querying.
* **Consistency and Availability:** When scaling horizontally, ensuring data consistency (e.g., using the ACID properties) and availability (data is accessible even if some nodes fail) becomes harder. This is where NoSQL systems like **Cassandra use eventual consistency** to favor availability and partition tolerance (CAP theorem).
* **Indexing and Query Optimization:** Scaling can cause issues with indexing and query optimization, as distributing indices across multiple nodes can lead to inefficiencies. For example, joins, which are easy to perform on a single machine, become more complex when data is distributed across multiple nodes.

#### Solutions to Scaling:
* **Sharding:** In NoSQL databases (e.g., MongoDB, Cassandra), sharding is used to split data into smaller, manageable pieces (shards). Each shard is stored on a different node, allowing the database to scale out. Sharding is often based on certain key values (e.g., user ID or geographic region).
* **Distributed Databases:** Systems like Google Spanner or Amazon DynamoDB are designed to scale horizontally across many machines. They implement sophisticated algorithms for data replication, partitioning, and consistency to ensure that the system can handle large amounts of data and traffic efficiently.
* **Hadoop and Distributed File Systems:** Hadoop’s HDFS (Hadoop Distributed File System) is designed to store very large datasets across clusters of machines. MapReduce (Hadoop’s processing model) breaks large data tasks into smaller sub-tasks and distributes them across many nodes to process in parallel, enabling horizontal scaling for big data applications.

#### Why RDBMS Struggles with Sparse Data and Scaling:
Traditional RDBMSs are optimized for structured data with clear, predefined relationships and attributes. When dealing with large-scale sparse data or trying to scale horizontally, RDBMSs face significant difficulties:
* **Rigid Schema:** The fixed schema structure of RDBMSs doesn’t easily accommodate the dynamic, variable nature of sparse data, where different records may have different attributes.
* **Join Complexity:** RDBMSs rely heavily on joins to relate data from different tables. As data scales and becomes more sparse or distributed, these joins become inefficient and slow.
* **Single-Server Limitation:** RDBMSs are often limited by the resources of a single machine, making it hard to scale horizontally for very large datasets or high-traffic applications.

#### NoSQL and Hadoop as Solutions:
* **NoSQL** Databases (e.g., MongoDB, Cassandra, Couchbase) provide greater flexibility by allowing schema-less data structures. They are designed to handle large-scale, sparse, and unstructured data.
* **Hadoop:** Provides a distributed approach to both data storage and processing. It enables horizontal scaling and is capable of handling massive datasets by breaking them into smaller chunks and processing them in parallel across multiple machines.

